document.createElement('canvas')

  if(addBtn) addBtn.addEventListener('click', async function(e){
    e.preventDefault();
    
    const designer = DESIGNERS[currentDesigner];

    if (!designer.available) {
      const userEmail = prompt(`Enter your email to be notified when ${designer.name} becomes available:`);
      
      if (!userEmail || !userEmail.includes('@')) {
        if (userEmail !== null) alert('Please enter a valid email address');
        return;
      }
      
      addBtn.disabled = true;
      addBtn.textContent = 'Saving...';
      
      try {
        const pngDataUrl = await svgToPngDataUrl(svg, 1000);
        const sizeText = sizeSelect ? sizeSelect.value : 'M';
        
        const response = await fetch('https://uploads.pabon.shop/waitlist_handler.php', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            email: userEmail,
            designer: designer.name,
            size: sizeText,
            designImage: pngDataUrl
          })
        });
        
        const result = await response.json();
        
        if (result.success) {
          alert(result.message + '\n\n' + result.total_interested + ' people interested in this colorway!');
        } else {
          alert('Error: ' + result.message);
        }
      } catch (err) {
        alert('Failed to save notification: ' + err.message);
      } finally {
        addBtn.disabled = false;
        addBtn.textContent = 'NOTIFY ME';
      }
      return;
    }
    
    if(addBtn.disabled) {
      alert('Cannot add to cart: color constraints exceeded. Please reduce the number of colors used.');
      return;
    }
    
    // Check if we have a product variant ID
    if (!SINGLE_VARIANT_ID) {
      alert('⚠️ Product not configured!\n\nPlease follow these steps:\n\n1. Go to Customize Theme\n2. Click on the Sweater Designer section\n3. Select your sweater product\n4. Save\n\nOr paste a Variant ID in the Fallback field.\n\nPress Ctrl+D to see debug info.');
      console.error('No variant ID found. Configure the section settings or check the console for details.');
      return;
    }
    
    if(addBtn.dataset.busy === '1') return;
    addBtn.dataset.busy = '1';
    addBtn.style.opacity = '0.6';
    const origText = addBtn.textContent;
    addBtn.textContent = 'Processing...';

    try {
      if(!svg) throw new Error('SVG not found.');

      const pngDataUrl = await svgToPngDataUrl(svg, 1000);
      
      // Always use the single variant ID
      const chosenVariant = SINGLE_VARIANT_ID;

      const timestamp = Date.now();
      const designerClean = designer.name.replace(/\s+/g, '_');
      const designId = `${designerClean}_${timestamp}`;
      const customName = designer.name + ' Design';

      // Get size from selector (stored as property, not variant)
      const sizeText = sizeSelect ? sizeSelect.value : 'M';
      
      console.log('=== SIZE DEBUG ===');
      console.log('Size selector value:', sizeText);
      console.log('Size will be stored in Size property');
      console.log('==================');

      const colorMapping = {};
      const swatchColors = getSwatchColors(currentDesigner);
      swatchColors.forEach(color => {
        colorMapping[normalizeColor(color.hex)] = color.name;
      });

      function countLayersByColor(layers) {
        const colorCounts = {};
        
        layers.forEach(layerId => {
          const color = getFill(layerId);
          if (color) {
            const normalizedColor = normalizeColor(color);
            const colorName = colorMapping[normalizedColor] || normalizedColor;
            
            if (!colorCounts[colorName]) {
              colorCounts[colorName] = {
                hex: normalizedColor,
                count: 0,
                layers: []
              };
            }
            colorCounts[colorName].count++;
            colorCounts[colorName].layers.push(layerId);
          }
        });
        
        return colorCounts;
      }

      const bodyLayerCounts = countLayersByColor(bodyLayers);
      const leftSleeveLayerCounts = countLayersByColor(leftSleeveLayers);
      const rightSleeveLayerCounts = countLayersByColor(rightSleeveLayers);
      const hemLayerCounts = countLayersByColor(hemLayers);

      const bodyUsed = Object.keys(bodyLayerCounts);
      const leftSleeveUsed = Object.keys(leftSleeveLayerCounts);
      const rightSleeveUsed = Object.keys(rightSleeveLayerCounts);
      
      const allLayerCounts = {};
      
      function addToTotalCounts(sectionCounts, sectionName) {
        Object.entries(sectionCounts).forEach(([colorName, data]) => {
          if (!allLayerCounts[colorName]) {
            allLayerCounts[colorName] = {
              hex: data.hex,
              bodyStripes: 0,
              leftSleeveStripes: 0,
              rightSleeveStripes: 0,
              hemStripes: 0,
              totalStripes: 0
            };
          }
          
          if (sectionName === 'body') allLayerCounts[colorName].bodyStripes = data.count;
          if (sectionName === 'leftSleeve') allLayerCounts[colorName].leftSleeveStripes = data.count;
          if (sectionName === 'rightSleeve') allLayerCounts[colorName].rightSleeveStripes = data.count;
          if (sectionName === 'hem') allLayerCounts[colorName].hemStripes = data.count;
          
          allLayerCounts[colorName].totalStripes += data.count;
        });
      }
      
      addToTotalCounts(bodyLayerCounts, 'body');
      addToTotalCounts(leftSleeveLayerCounts, 'leftSleeve');
      addToTotalCounts(rightSleeveLayerCounts, 'rightSleeve');
      addToTotalCounts(hemLayerCounts, 'hem');
      
      const productionSummary = Object.entries(allLayerCounts)
        .sort((a, b) => b[1].totalStripes - a[1].totalStripes)
        .map(([colorName, counts]) => {
          return `${colorName}: ${counts.totalStripes} stripes total (Body:${counts.bodyStripes}, L:${counts.leftSleeveStripes}, R:${counts.rightSleeveStripes}, Hem:${counts.hemStripes})`;
        })
        .join('; ');
      
      let publicImageUrl = '';
      let uploadSuccess = false;
      
      try {
        console.log('Uploading design to server...');
        
        const formatColorStripes = (counts) => {
          return Object.entries(counts)
            .map(([name, data]) => `${name} (${data.count} ${data.count === 1 ? 'stripe' : 'stripes'})`)
            .join(', ');
        };
        
        const uploadPayload = {
          imageData: pngDataUrl,
          designId: designId,
          designerName: designer.name,
          properties: {
            size: sizeText,
            bodyColors: `Body (${bodyLayers.length} stripes): ${formatColorStripes(bodyLayerCounts)}`,
            leftSleeveColors: `Left Sleeve (${leftSleeveLayers.length} stripes): ${formatColorStripes(leftSleeveLayerCounts)}`,
            rightSleeveColors: `Right Sleeve (${rightSleeveLayers.length} stripes): ${formatColorStripes(rightSleeveLayerCounts)}`,
            hemColors: `Hem (${hemLayers.length} stripes): ${formatColorStripes(hemLayerCounts)}`,
            productionSummary: productionSummary,
            totalStripes: Object.values(allLayerCounts).reduce((sum, c) => sum + c.totalStripes, 0),
            uniqueColors: Object.keys(allLayerCounts).length,
            timestamp: new Date().toISOString()
          }
        };
        
        const uploadResponse = await fetch('https://uploads.pabon.shop/upload.php', {
          method: 'POST',
          headers: { 
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(uploadPayload)
        });
        
        const uploadResult = await uploadResponse.json();
        console.log('Upload response:', uploadResult);
        
        if (uploadResult.success) {
          publicImageUrl = uploadResult.url;
          uploadSuccess = true;
          console.log('Design uploaded successfully. URL:', publicImageUrl);
        } else {
          console.error('Upload failed:', uploadResult.message);
        }
      } catch (uploadError) {
        console.error('Upload error:', uploadError);
      }
      
      const properties = { 
        "_Custom_Name": customName,
        "_Designer": designer.name,
        "_Design_ID": designId,
        "_Design_Date": new Date().toISOString().split('T')[0],
        "Size": sizeText,
        "_Design_PNG": pngDataUrl
      };
      
      if (uploadSuccess && publicImageUrl) {
        properties["_Design_Image_URL"] = publicImageUrl;
        properties["_Design_Status"] = "Uploaded Successfully";
      } else {
        properties["_Design_Status"] = "Upload Pending - Check Server";
        properties["_Design_Image_URL"] = "";
      }
      
      properties["_Body_Colors"] = bodyLayers.length > 0 ? 
        `Body (${bodyLayers.length} stripes): ${
          Object.entries(bodyLayerCounts)
            .map(([name, data]) => `${name} (${data.count} ${data.count === 1 ? 'stripe' : 'stripes'})`)
            .join(', ')
        }` : 'Body: No stripes';
      
      properties["_Left_Sleeve_Colors"] = leftSleeveLayers.length > 0 ?
        `Left Sleeve (${leftSleeveLayers.length} stripes): ${
          Object.entries(leftSleeveLayerCounts)
            .map(([name, data]) => `${name} (${data.count} ${data.count === 1 ? 'stripe' : 'stripes'})`)
            .join(', ')
        }` : 'Left Sleeve: No stripes';
      
      properties["_Right_Sleeve_Colors"] = rightSleeveLayers.length > 0 ?
        `Right Sleeve (${rightSleeveLayers.length} stripes): ${
          Object.entries(rightSleeveLayerCounts)
            .map(([name, data]) => `${name} (${data.count} ${data.count === 1 ? 'stripe' : 'stripes'})`)
            .join(', ')
        }` : 'Right Sleeve: No stripes';
      
      properties["_Hem_Colors"] = hemLayers.length > 0 ?
        `Hem/Cuffs (${hemLayers.length} stripes): ${
          Object.entries(hemLayerCounts)
            .map(([name, data]) => `${name} (${data.count} ${data.count === 1 ? 'stripe' : 'stripes'})`)
            .join(', ')
        }` : 'Hem/Cuffs: No stripes';
      
      properties["_Production_Summary"] = productionSummary;
      properties["_Total_Stripes"] = `${Object.values(allLayerCounts).reduce((sum, c) => sum + c.totalStripes, 0)} stripes across all sections`;
      properties["_Unique_Colors"] = `${Object.keys(allLayerCounts).length} unique colors`;
      
      const totalStripes = Object.values(allLayerCounts).reduce((sum, c) => sum + c.totalStripes, 0);
      const estimatedWeight = (totalStripes * 100) / 1000;
      properties["_Material_Estimate"] = `Approximately ${estimatedWeight.toFixed(2)} kg total wool needed`;

      console.log('Adding to cart with properties:', properties);
      console.log('Using single variant ID:', chosenVariant);
      
      const addResp = await fetch('/cart/add.js', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ 
          id: chosenVariant, 
          quantity: 1, 
          properties: properties 
        })
      });

      if(!addResp.ok) {
        const err = await addResp.json().catch(()=>({ message: 'Add to cart failed' }));
        throw new Error(err?.description || err?.message || 'Add failed');
      }

      const cartItem = await addResp.json();
      console.log('Successfully added to cart:', cartItem);

      if (uploadSuccess && publicImageUrl) {
        try {
          await fetch('https://uploads.pabon.shop/notify_order.php', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              design_id: designId,
              design_url: publicImageUrl,
              designer: designer.name,
              size: sizeText,
              properties: properties,
              production_data: allLayerCounts,
              cart_token: cartItem.key || '',
              timestamp: new Date().toISOString()
            })
          });
          console.log('Server notified of pending order with production data');
          console.log('Size sent to factory:', sizeText);
        } catch (notifyError) {
          console.warn('Notification failed (non-critical):', notifyError);
        }
      }

      showConfirmation();

      console.log('Design successfully added to cart. Customer can download from order details.');

    } catch(err) {
      console.error('Add-to-cart error', err);
      alert('Error adding to cart: ' + (err.message || err));
    } finally {
      addBtn.dataset.busy = '0';
      addBtn.style.opacity = '1';
      addBtn.textContent = origText;
    }
  });

  makeShapesClickable();
  buildSwatches();
  applyDefaults();
  refreshConstraints();
  updateAddToCartButton();
  updateMiniThumbnail(0);
  syncMobileButtons();

  // Color picker tooltip functionality
  const colorPickerTooltip = document.getElementById('color-picker-tooltip');
  let tooltipDismissed = false;

  function showColorPickerTooltip() {
    if (!tooltipDismissed && colorPickerTooltip) {
      colorPickerTooltip.style.display = 'block';
    }
  }

  function hideColorPickerTooltip() {
    if (colorPickerTooltip) {
      colorPickerTooltip.style.display = 'none';
      tooltipDismissed = true;
    }
  }

  setTimeout(showColorPickerTooltip, 500);

  if (colorPickerTooltip) {
    colorPickerTooltip.addEventListener('mouseenter', hideColorPickerTooltip);
  }

  document.addEventListener('click', function(e) {
    if (e.target.classList.contains('color-swatch')) {
      hideColorPickerTooltip();
    }
  });

  // ========== TUTORIAL ANIMATION ==========
  const tutorialBtn = document.getElementById('tutorial-btn');
  const tutorialCursor = document.getElementById('tutorial-cursor');
  let tutorialPlaying = false;

  if (tutorialBtn && tutorialCursor) {
    tutorialBtn.addEventListener('click', playTutorial);
  }

  async function playTutorial() {
    if (tutorialPlaying) return;
    tutorialPlaying = true;
    tutorialBtn.classList.add('playing');
    tutorialBtn.textContent = '⏸';
    
    // Get elements - find the actual shape elements that have click handlers
    const allSwatches = swatchContainer.querySelectorAll('.color-swatch');
    const firstSwatch = allSwatches[0];
    const secondSwatch = allSwatches[1];
    
    // Find stripe elements from their parent groups
    const firstStripeGroup = document.getElementById('Laag_3');
    const firstStripe = firstStripeGroup ? firstStripeGroup.querySelector('path, rect, polygon, polyline, circle, ellipse') : null;
    
    const secondStripeGroup = document.getElementById('Laag_5');
    const secondStripe = secondStripeGroup ? secondStripeGroup.querySelector('path, rect, polygon, polyline, circle, ellipse') : null;
    
    if (!firstSwatch || !firstStripe) {
      tutorialPlaying = false;
      tutorialBtn.classList.remove('playing');
      tutorialBtn.textContent = '?';
      return;
    }
    
    // Helper function to move cursor
    function moveCursor(element, duration = 800) {
      return new Promise(resolve => {
        const rect = element.getBoundingClientRect();
        const x = rect.left + rect.width / 2;
        const y = rect.top + rect.height / 2;
        
        tutorialCursor.style.transition = `all ${duration}ms cubic-bezier(0.4, 0, 0.2, 1)`;
        tutorialCursor.style.left = x + 'px';
        tutorialCursor.style.top = y + 'px';
        
        setTimeout(resolve, duration);
      });
    }
    
    // Helper function to click animation
    function simulateClick() {
      return new Promise(resolve => {
        tutorialCursor.classList.add('clicking');
        setTimeout(() => {
          tutorialCursor.classList.remove('clicking');
          resolve();
        }, 300);
      });
    }
    
    // Helper to actually change stripe color
    function changeStripeColor(stripe, color) {
      if (stripe && color) {
        stripe.style.fill = normalizeColor(color);
      }
    }
    
    // Start animation - position cursor off screen
    tutorialCursor.classList.add('active');
    tutorialCursor.style.transition = 'none';
    tutorialCursor.style.left = '-100px';
    tutorialCursor.style.top = '-100px';
    tutorialCursor.style.opacity = '1';
    
    await new Promise(resolve => setTimeout(resolve, 100));
    
    // FIRST INTERACTION
    // Step 1: Move to first swatch
    firstSwatch.classList.add('tutorial-highlight');
    await moveCursor(firstSwatch, 1000);
    await new Promise(resolve => setTimeout(resolve, 300));
    
    // Step 2: Click swatch and select color
    await simulateClick();
    firstSwatch.classList.remove('tutorial-highlight');
    firstSwatch.click(); // Select the swatch
    const firstColor = firstSwatch.style.backgroundColor || getComputedStyle(firstSwatch).backgroundColor;
    await new Promise(resolve => setTimeout(resolve, 500));
    
    // Step 3: Move to first stripe
    firstStripe.classList.add('tutorial-highlight');
    await moveCursor(firstStripe, 1000);
    await new Promise(resolve => setTimeout(resolve, 300));
    
    // Step 4: Click stripe and apply color
    await simulateClick();
    firstStripe.classList.remove('tutorial-highlight');
    changeStripeColor(firstStripe, activeColor); // Use the active color
    refreshConstraints();
    await new Promise(resolve => setTimeout(resolve, 800));
    
    // SECOND INTERACTION
    if (secondSwatch && secondStripe) {
      // Move to second swatch
      secondSwatch.classList.add('tutorial-highlight');
      await moveCursor(secondSwatch, 800);
      await new Promise(resolve => setTimeout(resolve, 200));
      
      // Click second swatch
      await simulateClick();
      secondSwatch.classList.remove('tutorial-highlight');
      secondSwatch.click();
      await new Promise(resolve => setTimeout(resolve, 400));
      
      // Move to second stripe
      secondStripe.classList.add('tutorial-highlight');
      await moveCursor(secondStripe, 800);
      await new Promise(resolve => setTimeout(resolve, 200));
      
      // Click second stripe and apply color
      await simulateClick();
      secondStripe.classList.remove('tutorial-highlight');
      changeStripeColor(secondStripe, activeColor);
      refreshConstraints();
      await new Promise(resolve => setTimeout(resolve, 500));
    }
    
    // End animation - fade out and hide cursor
    tutorialCursor.style.transition = 'opacity 0.3s ease';
    tutorialCursor.style.opacity = '0';
    
    await new Promise(resolve => setTimeout(resolve, 300));
    
    tutorialCursor.classList.remove('active');
    tutorialCursor.style.left = '-100px';
    tutorialCursor.style.top = '-100px';
    
    tutorialPlaying = false;
    tutorialBtn.classList.remove('playing');
    tutorialBtn.textContent = '?';
  }
  // ========== END TUTORIAL ANIMATION ==========
}
</script>