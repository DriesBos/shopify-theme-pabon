


  // Current state
  let currentDesigner = 0;
  let activeColor = getSwatchColors(0)[0].hex;
  let currentCarouselIndex = 0;
  let carouselSlideCount = 0;

  // ============================================
  // CAROUSEL FUNCTIONALITY
  // ============================================
  
  const carouselContainer = document.getElementById('carousel-container');
  const carouselTrack = document.getElementById('carousel-track');
  const carouselPrev = document.getElementById('carousel-prev');
  const carouselNext = document.getElementById('carousel-next');
  const carouselDots = document.getElementById('carousel-dots');
  const carouselVideo = document.getElementById('carousel-video');
  const carouselSoundToggle = document.getElementById('carousel-sound-toggle');
  const soundOnIcon = document.getElementById('sound-on-icon');
  const soundOffIcon = document.getElementById('sound-off-icon');
  
  let isVideoMuted = false; // Track mute state
  
  function updateCarousel(designerIndex) {
    const data = galleryData[designerIndex] || {};
    const images = (data.images || []).filter(img => img && img !== '');
    const video = data.video || '';
    
    // Reset
    currentCarouselIndex = 0;
    
    // Build list of all slides (images + video)
    const slideContent = [];
    images.forEach((img, i) => {
      slideContent.push({ type: 'image', src: img, index: i });
    });
    if (video) {
      slideContent.push({ type: 'video', src: video, index: images.length });
    }
    
    carouselSlideCount = slideContent.length;
    
    // Update image slides
    for (let i = 0; i < 3; i++) {
      const img = document.getElementById(`carousel-img-${i}`);
      const slide = img?.parentElement;
      if (img && slide) {
        if (images[i]) {
          img.src = images[i];
          slide.style.display = 'none';
          slide.classList.remove('active');
          slide.dataset.index = i;
        } else {
          slide.style.display = 'none';
          slide.classList.remove('active');
        }
      }
    }
    
    // Update video slide
    const videoSlide = document.querySelector('.carousel-video-slide');
    if (video && carouselVideo && videoSlide) {
      // Reset video
      carouselVideo.pause();
      carouselVideo.src = video;
      carouselVideo.load();
      videoSlide.style.display = 'none';
      videoSlide.classList.remove('active');
      videoSlide.dataset.index = images.length;
    } else if (videoSlide) {
      videoSlide.style.display = 'none';
      videoSlide.classList.remove('active');
    }
    
    // Rebuild dots
    if (carouselDots) {
      carouselDots.innerHTML = '';
      slideContent.forEach((item, i) => {
        const dot = document.createElement('span');
        dot.className = 'carousel-dot' + (item.type === 'video' ? ' carousel-dot-video' : '');
        dot.dataset.index = i;
        if (i === 0) dot.classList.add('active');
        carouselDots.appendChild(dot);
      });
    }
    
    // Handle single slide or no slides case
    if (carouselSlideCount <= 1) {
      carouselContainer?.classList.add('single-slide');
    } else {
      carouselContainer?.classList.remove('single-slide');
    }
    
    // Show first slide
    if (carouselSlideCount > 0) {
      showSlide(0);
    }
  }
  
  function showSlide(index) {
    const data = galleryData[currentDesigner] || {};
    const images = (data.images || []).filter(img => img && img !== '');
    const hasVideo = !!(data.video);
    
    if (carouselSlideCount === 0) return;
    if (index < 0) index = carouselSlideCount - 1;
    if (index >= carouselSlideCount) index = 0;
    currentCarouselIndex = index;
    
    const videoSlideIndex = hasVideo ? images.length : -1;
    const isOnVideoSlide = (index === videoSlideIndex);
    
    // Show/hide sound toggle based on whether we're on video slide
    if (carouselSoundToggle) {
      carouselSoundToggle.style.display = isOnVideoSlide ? 'flex' : 'none';
    }
    
    // Hide all slides first
    const allSlides = carouselTrack?.querySelectorAll('.carousel-slide');
    allSlides?.forEach(slide => {
      slide.classList.remove('active');
      slide.style.display = 'none';
    });
    
    // Pause video
    if (carouselVideo) {
      carouselVideo.pause();
    }
    
    // Show the correct slide
    if (index < images.length) {
      // It's an image slide
      const imgSlide = document.getElementById(`carousel-img-${index}`)?.parentElement;
      if (imgSlide) {
        imgSlide.style.display = 'flex';
        imgSlide.classList.add('active');
      }
    } else if (hasVideo && isOnVideoSlide) {
      // It's the video slide
      const videoSlide = document.querySelector('.carousel-video-slide');
      if (videoSlide) {
        videoSlide.style.display = 'flex';
        videoSlide.classList.add('active');
        // Autoplay video with current mute state
        if (carouselVideo) {
          carouselVideo.muted = isVideoMuted;
          carouselVideo.play().catch(e => console.log('Autoplay prevented:', e));
        }
      }
    }
    
    // Update dots
    const dots = carouselDots?.querySelectorAll('.carousel-dot');
    dots?.forEach((dot, i) => {
      dot.classList.toggle('active', i === index);
    });
  }
  
  carouselPrev?.addEventListener('click', (e) => {
    e.stopPropagation();
    showSlide(currentCarouselIndex - 1);
  });
  
  carouselNext?.addEventListener('click', (e) => {
    e.stopPropagation();
    showSlide(currentCarouselIndex + 1);
  });
  
  carouselDots?.addEventListener('click', (e) => {
    const dot = e.target.closest('.carousel-dot');
    if (dot) {
      e.stopPropagation();
      const index = parseInt(dot.dataset.index);
      if (!isNaN(index)) {
        showSlide(index);
      }
    }
  });
  
  // Sound toggle functionality
  carouselSoundToggle?.addEventListener('click', (e) => {
    e.stopPropagation();
    if (carouselVideo) {
      isVideoMuted = !isVideoMuted;
      carouselVideo.muted = isVideoMuted;
      updateSoundIcon();
    }
  });
  
  function updateSoundIcon() {
    if (isVideoMuted) {
      soundOnIcon.style.display = 'none';
      soundOffIcon.style.display = 'block';
      carouselSoundToggle?.classList.add('muted');
    } else {
      soundOnIcon.style.display = 'block';
      soundOffIcon.style.display = 'none';
      carouselSoundToggle?.classList.remove('muted');
    }
  }
  
  // Keyboard navigation for carousel
  document.addEventListener('keydown', (e) => {
    if (expandedOverlay?.style.display === 'block') {
      if (e.key === 'ArrowLeft') showSlide(currentCarouselIndex - 1);
      if (e.key === 'ArrowRight') showSlide(currentCarouselIndex + 1);
      if (e.key === 'Escape') closeExpandedOverlay();
      // M key to toggle mute
      if (e.key === 'm' || e.key === 'M') {
        if (carouselVideo && carouselSoundToggle?.style.display === 'flex') {
          isVideoMuted = !isVideoMuted;
          carouselVideo.muted = isVideoMuted;
          updateSoundIcon();
        }
      }
    }
  });

  // ============================================
  // EXPANDED OVERLAY WITH ARTIST INFO
  // ============================================
  
  const expandedOverlay = document.getElementById('expanded-designer-overlay');
  const expandedName = document.getElementById('expanded-designer-name');
  const expandedPaintingName = document.getElementById('expanded-painting-name');
  const expandedBio = document.getElementById('expanded-bio');
  const expandedWikipedia = document.getElementById('expanded-wikipedia');
  const closeOverlayBtn = document.getElementById('close-overlay-btn');
  
  function openExpandedOverlay(designerIndex) {
    const designer = DESIGNERS[designerIndex];
    const data = galleryData[designerIndex] || {};
    
    // Update carousel
    updateCarousel(designerIndex);
    
    // Update artist info
    if (expandedName) expandedName.textContent = designer.name;
    if (expandedPaintingName) expandedPaintingName.textContent = data.paintingName || '';
    if (expandedBio) expandedBio.textContent = data.bio || '';
    
    if (expandedWikipedia) {
      if (data.wikipedia) {
        expandedWikipedia.href = data.wikipedia;
        expandedWikipedia.style.display = 'inline-flex';
      } else {
        expandedWikipedia.style.display = 'none';
      }
    }
    
    if (expandedOverlay) expandedOverlay.style.display = 'block';
    document.body.style.overflow = 'hidden';
    
    // Check if we should start with video
    const images = (data.images || []).filter(img => img && img !== '');
    const hasVideo = !!(data.video);
    if (data.startWithVideo && hasVideo) {
      // Jump to video slide
      const videoSlideIndex = images.length;
      showSlide(videoSlideIndex);
    }
  }
  
  function closeExpandedOverlay() {
    if (expandedOverlay) expandedOverlay.style.display = 'none';
    document.body.style.overflow = '';
    if (carouselVideo) {
      carouselVideo.pause();
      carouselVideo.currentTime = 0;
    }
    // Hide sound toggle
    if (carouselSoundToggle) {
      carouselSoundToggle.style.display = 'none';
    }
  }
  
  closeOverlayBtn?.addEventListener('click', (e) => {
    e.stopPropagation();
    closeExpandedOverlay();
  });
  
  expandedOverlay?.addEventListener('click', (e) => {
    if (e.target === expandedOverlay) {
      closeExpandedOverlay();
    }
  });
  
  // Prevent clicks inside content from closing
  document.getElementById('expanded-content')?.addEventListener('click', (e) => {
    e.stopPropagation();
  });

  // ============================================
  // VIDEO THUMBNAIL FUNCTIONALITY
  // ============================================
  
  const miniDesignerVideo = document.getElementById('mini-designer-video');
  const miniDesignerVideoMobile = document.getElementById('mini-designer-video-mobile');
  let videoPreviewTimer = null;
  
  function updateMiniThumbnail(designerIndex) {
    const designer = DESIGNERS[designerIndex];
    const data = galleryData[designerIndex] || {};
    
    const miniImg = document.getElementById('mini-designer-img');
    const miniImgMobile = document.getElementById('mini-designer-img-mobile');
    
    // Clear any existing video preview timer
    if (videoPreviewTimer) {
      clearInterval(videoPreviewTimer);
      videoPreviewTimer = null;
    }
    
    // Check if we should use video as thumbnail
    if (data.videoAsThumbnail && data.video) {
      // Desktop
      if (miniDesignerVideo && miniImg) {
        miniDesignerVideo.src = data.video;
        miniDesignerVideo.style.display = 'block';
        miniImg.style.display = 'none';
        
        if (data.videoPreview) {
          // 5-second preview loop
          miniDesignerVideo.currentTime = 0;
          miniDesignerVideo.play().catch(() => {});
          
          videoPreviewTimer = setInterval(() => {
            if (miniDesignerVideo.currentTime >= 5) {
              miniDesignerVideo.currentTime = 0;
            }
          }, 100);
        } else {
          // Just show first frame (poster)
          miniDesignerVideo.currentTime = 0;
          miniDesignerVideo.pause();
        }
      }
      
      // Mobile
      if (miniDesignerVideoMobile && miniImgMobile) {
        miniDesignerVideoMobile.src = data.video;
        miniDesignerVideoMobile.style.display = 'block';
        miniImgMobile.style.display = 'none';
        
        if (data.videoPreview) {
          miniDesignerVideoMobile.currentTime = 0;
          miniDesignerVideoMobile.play().catch(() => {});
        }
      }
    } else {
      // Use image thumbnail - prefer from settings, fallback to hardcoded
      const imageUrl = data.thumbnail || designer.fallbackThumbnail;
      
      if (miniImg) {
        miniImg.src = imageUrl;
        miniImg.style.display = 'block';
      }
      if (miniDesignerVideo) {
        miniDesignerVideo.style.display = 'none';
        miniDesignerVideo.pause();
      }
      
      if (miniImgMobile) {
        miniImgMobile.src = imageUrl;
        miniImgMobile.style.display = 'block';
      }
      if (miniDesignerVideoMobile) {
        miniDesignerVideoMobile.style.display = 'none';
        miniDesignerVideoMobile.pause();
      }
    }
  }

  // ============================================
  // PALETTE SELECTOR INTEGRATION
  // ============================================
  
  document.addEventListener('paletteSelected', function(e) {
    const newDesignerIndex = e.detail.designerIndex;
    if (newDesignerIndex !== currentDesigner && DESIGNERS[newDesignerIndex]) {
      switchDesigner(newDesignerIndex);
    }
  });

  const maxBodyColors = 4;
  const maxSleeveColors = 5;

  // Layer categories
  const bodyLayers = ["Laag_3","Laag_4","Laag_5","Laag_6","Laag_7","Laag_8","Laag_9","Laag_11","Laag_12","Laag_15"];
  const leftSleeveLayers = ["Laag_10","Laag_14","Laag_16","Laag_17","Laag_18","Laag_19"];
  const rightSleeveLayers = ["Laag_21","Laag_28","Laag_23","Laag_24","Laag_25","Laag_26"];
  const hemLayers = ["Laag_2","Laag_13","Laag_22","Laag_27","hem","neck","leftcuff","rightcuff","leftcuff-2"];
  
  const sleeveLayers = [...leftSleeveLayers, ...rightSleeveLayers];

  // elements
  const swatchContainer = document.getElementById('swatch-container');
  const infoBtn = document.getElementById('info-btn');
  const tooltip = document.getElementById('info-tooltip');
  const addBtn = document.getElementById('add-to-cart');
  const defaultBtn = document.getElementById('default-btn');
  const randomBtn = document.getElementById('random-btn');
  const nameInput = document.getElementById('custom-name');
  const nameLabel = document.getElementById('name-label-preview');
  const svg = document.getElementById('sweater-svg');
  const sizeSelect = document.getElementById('sweater-size');
  const confirmPanel = document.getElementById('sweater-confirm');
  const confirmGo = document.getElementById('sweater-confirm-go');
  const confirmKeep = document.getElementById('sweater-confirm-keep');
  const colorWarning = document.getElementById('color-warning');
  const colorWarningText = document.getElementById('color-warning-text');
  const nextDesignerBtn = document.getElementById('next-designer');
  const prevDesignerBtn = document.getElementById('prev-designer');
  const designerNameEl = document.getElementById('designer-name');
  
  // Get the single product variant ID
  const productVariantIdInput = document.getElementById('product-variant-id');
  let SINGLE_VARIANT_ID = productVariantIdInput ? productVariantIdInput.value : null;
  
  // Clean up the variant ID (remove any whitespace)
  if (SINGLE_VARIANT_ID) {
    SINGLE_VARIANT_ID = SINGLE_VARIANT_ID.trim();
    if (SINGLE_VARIANT_ID === '' || SINGLE_VARIANT_ID === 'null' || SINGLE_VARIANT_ID === 'undefined') {
      SINGLE_VARIANT_ID = null;
    }
  }
  
  // Debug panel toggle (Ctrl+D)
  document.addEventListener('keydown', function(e) {
    if (e.ctrlKey && e.key === 'd') {
      e.preventDefault();
      const debugPanel = document.getElementById('debug-info');
      if (debugPanel) {
        debugPanel.style.display = debugPanel.style.display === 'none' ? 'block' : 'none';
      }
    }
  });
  
  // Update debug info
  const debugProduct = document.getElementById('debug-product');
  const debugVariant = document.getElementById('debug-variant');
  if (debugProduct) debugProduct.textContent = '{% if section.settings.sweater_product %}{{ section.settings.sweater_product.title }}{% else %}Not configured{% endif %}';
  if (debugVariant) debugVariant.textContent = SINGLE_VARIANT_ID || 'Not found';
  
  console.log('=== SWEATER DESIGNER DEBUG ===');
  console.log('Product configured:', '{% if section.settings.sweater_product %}Yes - {{ section.settings.sweater_product.title }}{% else %}No{% endif %}');
  console.log('Raw variant value from input:', productVariantIdInput ? productVariantIdInput.value : 'input not found');
  console.log('Cleaned variant ID:', SINGLE_VARIANT_ID);
  console.log('Variant ID type:', typeof SINGLE_VARIANT_ID);
  console.log('Section settings product:', {% if section.settings.sweater_product %}true{% else %}false{% endif %});
  console.log('Fallback variant ID:', '{{ section.settings.fallback_variant_id }}');
  console.log('Press Ctrl+D to show debug panel');
  console.log('==============================');
  
  // Mini designer image elements
  const miniDesignerImage = document.getElementById('mini-designer-image');
  const miniDesignerImg = document.getElementById('mini-designer-img');
  const miniDesignerImageMobile = document.getElementById('mini-designer-image-mobile');
  const miniDesignerImgMobile = document.getElementById('mini-designer-img-mobile');

  // Mini designer image click handlers
  function setupMiniImageClick(element) {
    if (element) {
      element.addEventListener('click', () => {
        openExpandedOverlay(currentDesigner);
      });
    }
  }
  
  setupMiniImageClick(miniDesignerImage);
  setupMiniImageClick(miniDesignerImageMobile);

  function switchDesigner(designerIndex) {
    if (!DESIGNERS[designerIndex]) return;
    
    currentDesigner = designerIndex;
    const designer = DESIGNERS[currentDesigner];
    
    designerNameEl.textContent = designer.name;
    updateMiniThumbnail(designerIndex);
    
    prevDesignerBtn.style.opacity = currentDesigner === 0 ? '0.3' : '1';
    nextDesignerBtn.style.opacity = currentDesigner === Object.keys(DESIGNERS).length - 1 ? '0.3' : '1';
    
    updateAddToCartButton();
    buildSwatches();
    applyDefaults();
    refreshConstraints();
    syncMobileButtons();
    
    // Dispatch event to update palette selector
    const event = new CustomEvent('designerChanged', { 
      detail: { designerIndex: currentDesigner } 
    });
    document.dispatchEvent(event);
  }

  function updateAddToCartButton() {
    const designer = DESIGNERS[currentDesigner];
    const buttons = [
      {btn: addBtn, tooltipId: 'coming-soon-tooltip'},
      {btn: document.getElementById('add-to-cart-mobile'), tooltipId: 'coming-soon-tooltip-mobile'}
    ];
    
    buttons.forEach(({btn, tooltipId}) => {
      if (!btn) return;
      
      // Remove existing tooltip if present
      const existingTooltip = document.getElementById(tooltipId);
      if (existingTooltip) existingTooltip.remove();
      
      if (!designer.available) {
        btn.textContent = 'NOTIFY ME';
        btn.style.background = '#FF6B35';
        btn.style.color = '#fff';
        btn.style.cursor = 'pointer';
        btn.disabled = false;
        btn.style.position = 'relative';
        
        // Create tooltip element (hidden by default)
        const tooltip = document.createElement('div');
        tooltip.id = tooltipId;
        tooltip.textContent = 'Coming Soon';
        tooltip.style.cssText = 'position: absolute; bottom: 105%; left: 50%; transform: translateX(-50%); background: #333; color: white; padding: 6px 12px; border-radius: 4px; font-size: 12px; white-space: nowrap; pointer-events: none; z-index: 1000; opacity: 0; transition: opacity 0.2s;';
        
        // Add arrow
        const arrow = document.createElement('div');
        arrow.style.cssText = 'position: absolute; top: 100%; left: 50%; transform: translateX(-50%); width: 0; height: 0; border-left: 6px solid transparent; border-right: 6px solid transparent; border-top: 6px solid #333;';
        tooltip.appendChild(arrow);
        
        btn.appendChild(tooltip);
        
        // Show tooltip on hover
        btn.addEventListener('mouseenter', () => {
          tooltip.style.opacity = '1';
        });
        btn.addEventListener('mouseleave', () => {
          tooltip.style.opacity = '0';
        });
      } else {
        btn.textContent = 'ADD TO BAG';
        btn.style.background = '#0090C1';
        btn.style.color = '#fff';
        btn.style.cursor = 'pointer';
        btn.disabled = false;
        btn.style.position = '';
      }
    });
  }

  function syncMobileButtons() {
    const mobileAddBtn = document.getElementById('add-to-cart-mobile');
    const mobileDefaultBtn = document.getElementById('default-btn-mobile');
    const mobileRandomBtn = document.getElementById('random-btn-mobile');
    const mobileInfoBtn = document.getElementById('info-btn-mobile');
    const mobileSizeSelect = document.getElementById('sweater-size-mobile');
    const mobileZoomIn = document.getElementById('mobile-zoom-in');
    const mobileZoomOut = document.getElementById('mobile-zoom-out');
    
    if (window.innerWidth <= 768) {
      if (mobileZoomIn) mobileZoomIn.style.display = 'flex';
      if (mobileZoomOut) mobileZoomOut.style.display = 'flex';
    }
    
    if (mobileAddBtn) {
      mobileAddBtn.replaceWith(mobileAddBtn.cloneNode(true));
      const newMobileAddBtn = document.getElementById('add-to-cart-mobile');
      newMobileAddBtn.addEventListener('click', (e) => {
        if (mobileSizeSelect && sizeSelect) {
          sizeSelect.value = mobileSizeSelect.value;
        }
        addBtn.click();
      });
    }
    
    if (mobileDefaultBtn) {
      mobileDefaultBtn.replaceWith(mobileDefaultBtn.cloneNode(true));
      const newMobileDefaultBtn = document.getElementById('default-btn-mobile');
      newMobileDefaultBtn.addEventListener('click', () => defaultBtn.click());
    }
    
    if (mobileRandomBtn) {
      mobileRandomBtn.replaceWith(mobileRandomBtn.cloneNode(true));
      const newMobileRandomBtn = document.getElementById('random-btn-mobile');
      newMobileRandomBtn.addEventListener('click', () => randomBtn.click());
    }
    
    if (mobileInfoBtn) {
      mobileInfoBtn.replaceWith(mobileInfoBtn.cloneNode(true));
      const newMobileInfoBtn = document.getElementById('info-btn-mobile');
      newMobileInfoBtn.addEventListener('mouseenter', () => infoBtn.dispatchEvent(new Event('mouseenter')));
      newMobileInfoBtn.addEventListener('mouseleave', () => infoBtn.dispatchEvent(new Event('mouseleave')));
    }
    
    if (mobileZoomIn) {
      mobileZoomIn.replaceWith(mobileZoomIn.cloneNode(true));
      const newMobileZoomIn = document.getElementById('mobile-zoom-in');
      newMobileZoomIn.addEventListener('click', () => {
        if (currentZoom < maxZoom) {
          currentZoom = Math.min(maxZoom, currentZoom + zoomStep);
          updateZoom();
        }
      });
    }
    
    if (mobileZoomOut) {
      mobileZoomOut.replaceWith(mobileZoomOut.cloneNode(true));
      const newMobileZoomOut = document.getElementById('mobile-zoom-out');
      newMobileZoomOut.addEventListener('click', () => {
        if (currentZoom > minZoom) {
          currentZoom = Math.max(minZoom, currentZoom - zoomStep);
          updateZoom();
        }
      });
    }
    
    setTimeout(() => {
      updateAddToCartButton();
    }, 100);
  }

  // Zoom functionality
  let currentZoom = 1;
  const minZoom = 0.8;
  const maxZoom = 2.5;
  const zoomStep = 0.2;

  function updateZoom() {
    const sweaterWrapper = document.getElementById('sweater-svg-wrapper');
    if (sweaterWrapper) {
      sweaterWrapper.style.transform = `scale(${currentZoom})`;
      
      const mobileZoomOut = document.getElementById('mobile-zoom-out');
      const mobileZoomIn = document.getElementById('mobile-zoom-in');
      
      if (mobileZoomOut) mobileZoomOut.style.opacity = currentZoom <= minZoom ? '0.5' : '1';
      if (mobileZoomIn) mobileZoomIn.style.opacity = currentZoom >= maxZoom ? '0.5' : '1';
    }
  }

  if (nextDesignerBtn) {
    nextDesignerBtn.addEventListener('click', () => {
      if (currentDesigner < Object.keys(DESIGNERS).length - 1) {
        switchDesigner(currentDesigner + 1);
      }
    });
  }
  
  if (prevDesignerBtn) {
    prevDesignerBtn.addEventListener('click', () => {
      if (currentDesigner > 0) {
        switchDesigner(currentDesigner - 1);
      }
    });
  }

  function normalizeColor(c) {
    if(!c) return c;
    c = String(c).trim().toLowerCase();
    if(c.indexOf('rgb') === 0) {
      const nums = c.replace(/rgba?|\(|\)|\s/g,'').split(',').map(n=>parseInt(n,10)||0);
      if(nums.length>=3) c = '#' + nums.slice(0,3).map(n=>n.toString(16).padStart(2,'0')).join('');
    }
    const blacks = ['#000','#000000','black','#050505','#1d1d1b','#070606'];
    if(blacks.includes(c)) return '#000000';
    return c;
  }

  function buildSwatches() {
    const swatchColors = getSwatchColors(currentDesigner);
    swatchContainer.innerHTML = '';
    activeColor = swatchColors[0].hex;
    
    swatchColors.forEach((colorObj, i) => {
      const sw = document.createElement('div');
      sw.className = 'color-swatch' + (i === 0 ? ' active' : '');
      sw.style.backgroundColor = colorObj.hex;
      sw.title = colorObj.name + ' (' + colorObj.hex + ')';
      sw.addEventListener('click', () => {
        document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('active'));
        sw.classList.add('active');
        activeColor = colorObj.hex;
      });
      swatchContainer.appendChild(sw);
    });
  }

  function getFirstShapeById(id) {
    const g = document.getElementById(id);
    if(!g) return null;
    return g.querySelector('path, rect, polygon, polyline, circle, ellipse');
  }

  function applyDefaults() {
    const designer = DESIGNERS[currentDesigner];
    
    Object.keys(designer.defaults).forEach(layerId=>{
      const g = document.getElementById(layerId);
      if(!g) return;
      g.querySelectorAll('path, rect, polygon, polyline, circle, ellipse').forEach(s=>{
        s.style.fill = designer.defaults[layerId];
      });
    });
    ['hem','neck','leftcuff','rightcuff','leftcuff-2'].forEach(id=>{
      const g = document.getElementById(id);
      if(!g) return;
      const def = designer.defaults[id] || designer.defaults['hem'] || '#8c6f64';
      g.querySelectorAll('path, rect, polygon, polyline, circle, ellipse').forEach(s=> s.style.fill = def);
    });
    refreshConstraints();
  }

  function makeShapesClickable() {
    const allIds = new Set(Object.keys(DESIGNERS[0].defaults));
    bodyLayers.forEach(x=>allIds.add(x));
    sleeveLayers.forEach(x=>allIds.add(x));
    hemLayers.forEach(x=>allIds.add(x));
    ['hem','neck','leftcuff','rightcuff','leftcuff-2'].forEach(x=>allIds.add(x));

    allIds.forEach(layerId=>{
      const g = document.getElementById(layerId);
      if(!g) return;
      const shapes = g.querySelectorAll('path, rect, polygon, polyline, circle, ellipse');
      shapes.forEach(s=>{
        s.classList.add('sweater-layer');
        if(!(s.style && s.style.fill)) {
          const attr = s.getAttribute('fill');
          if(attr) s.style.fill = normalizeColor(attr);
        } else {
          s.style.fill = normalizeColor(s.style.fill);
        }
        s.addEventListener('click', function(){
          if(!activeColor) return;
          s.style.fill = normalizeColor(activeColor);
          refreshConstraints();
        });
      });
    });
  }

  function getFill(layerId) {
    const s = getFirstShapeById(layerId);
    if(!s) return null;
    const f = (s.style && s.style.fill) ? s.style.fill : s.getAttribute('fill');
    return normalizeColor(f);
  }

  function uniqueColors(layers) {
    const set = new Set();
    layers.forEach(l=>{
      const f = getFill(l);
      if(f) set.add(f);
    });
    return Array.from(set);
  }

  function refreshConstraints() {
    const bodyUsed = uniqueColors(bodyLayers);
    const leftSleeveUsed = uniqueColors(leftSleeveLayers);
    const rightSleeveUsed = uniqueColors(rightSleeveLayers);

    [...bodyLayers,...leftSleeveLayers,...rightSleeveLayers].forEach(layerId=>{
      const g = document.getElementById(layerId);
      if(!g) return;
      g.querySelectorAll('path, rect, polygon, polyline, circle, ellipse').forEach(s=> s.classList.remove('over-limit'));
    });

    let exceeded = false;
    let warningMessages = [];

    if(bodyUsed.length > maxBodyColors) {
      exceeded = true;
      warningMessages.push(`Body: ${bodyUsed.length}/${maxBodyColors} colors`);
      bodyLayers.forEach(layerId=>{
        const g = document.getElementById(layerId);
        if(!g) return;
        g.querySelectorAll('path, rect, polygon, polyline, circle, ellipse').forEach(s=> s.classList.add('over-limit'));
      });
    }

    if(leftSleeveUsed.length > maxSleeveColors) {
      exceeded = true;
      warningMessages.push(`Left sleeve: ${leftSleeveUsed.length}/${maxSleeveColors} colors`);
      leftSleeveLayers.forEach(layerId=>{
        const g = document.getElementById(layerId);
        if(!g) return;
        g.querySelectorAll('path, rect, polygon, polyline, circle, ellipse').forEach(s=> s.classList.add('over-limit'));
      });
    }

    if(rightSleeveUsed.length > maxSleeveColors) {
      exceeded = true;
      warningMessages.push(`Right sleeve: ${rightSleeveUsed.length}/${maxSleeveColors} colors`);
      rightSleeveLayers.forEach(layerId=>{
        const g = document.getElementById(layerId);
        if(!g) return;
        g.querySelectorAll('path, rect, polygon, polyline, circle, ellipse').forEach(s=> s.classList.add('over-limit'));
      });
    }

    if(exceeded && warningMessages.length > 0) {
      colorWarningText.textContent = 'Too many colors: ' + warningMessages.join(', ');
      colorWarning.style.display = 'block';
    } else {
      colorWarning.style.display = 'none';
    }

    if(addBtn) {
      addBtn.disabled = exceeded;
      addBtn.style.background = exceeded ? '#ccc' : '#0090C1';
      addBtn.style.cursor = exceeded ? 'default' : 'pointer';
    }
  }

  function randomizeWithinConstraints() {
    const swatchColors = getSwatchColors(currentDesigner);
    const availableColors = swatchColors.map(c => c.hex);
    
    const bodyPalette = availableColors.slice(0, Math.min(maxBodyColors, availableColors.length));
    bodyLayers.forEach(l=>{
      const g = document.getElementById(l);
      if(!g) return;
      const col = bodyPalette[Math.floor(Math.random()*bodyPalette.length)];
      g.querySelectorAll('path, rect, polygon, polyline, circle, ellipse').forEach(s=> s.style.fill = col);
    });

    const leftSleevePalette = availableColors.slice(0, Math.min(maxSleeveColors, availableColors.length));
    leftSleeveLayers.forEach(l=>{
      const g = document.getElementById(l);
      if(!g) return;
      const col = leftSleevePalette[Math.floor(Math.random()*leftSleevePalette.length)];
      g.querySelectorAll('path, rect, polygon, polyline, circle, ellipse').forEach(s=> s.style.fill = col);
    });

    const rightSleevePalette = availableColors.slice(0, Math.min(maxSleeveColors, availableColors.length));
    rightSleeveLayers.forEach(l=>{
      const g = document.getElementById(l);
      if(!g) return;
      const col = rightSleevePalette[Math.floor(Math.random()*rightSleevePalette.length)];
      g.querySelectorAll('path, rect, polygon, polyline, circle, ellipse').forEach(s=> s.style.fill = col);
    });

    hemLayers.forEach(l=>{
      const g = document.getElementById(l);
      if(!g) return;
      const col = availableColors[Math.floor(Math.random()*availableColors.length)];
      g.querySelectorAll('path, rect, polygon, polyline, circle, ellipse').forEach(s=> s.style.fill = col);
    });

    refreshConstraints();
  }

  if(defaultBtn) defaultBtn.addEventListener('click', applyDefaults);
  if(randomBtn) randomBtn.addEventListener('click', randomizeWithinConstraints);

  if(infoBtn && tooltip) {
    infoBtn.addEventListener('mouseenter', ()=> {
      const designer = DESIGNERS[currentDesigner];
      tooltip.querySelector('p').textContent = designer.tooltipTitle;
      tooltip.querySelector('img').src = designer.tooltipImage;
      tooltip.style.display = 'block';
    });
    infoBtn.addEventListener('mouseleave', ()=> tooltip.style.display = 'none');
  }

  if(nameInput) {
    nameInput.addEventListener('keypress', function(e){
      if(e.key === 'Enter') {
        nameLabel.textContent = nameInput.value || '';
        nameInput.blur();
      }
    });
  }

  function showConfirmation() {
    if(!confirmPanel) return;
    confirmPanel.style.display = 'block';
    clearTimeout(confirmPanel._hideTimer);
    confirmPanel._hideTimer = setTimeout(()=> confirmPanel.style.display = 'none', 6000);
  }
  if(confirmGo) confirmGo.addEventListener('click', ()=> window.location.href = "/cart");
  if(confirmKeep) confirmKeep.addEventListener('click', ()=> { if(confirmPanel) confirmPanel.style.display = 'none'; });

  async function svgToPngDataUrl(svgNode, maxWidth = 1000) {
    if(!svgNode) throw new Error('SVG not found for export');
    const clone = svgNode.cloneNode(true);
    clone.querySelectorAll('path, rect, polygon, polyline, circle, ellipse').forEach(el=>{
      const f = (el.style && el.style.fill) ? el.style.fill : el.getAttribute('fill');
      if(f) el.setAttribute('fill', f);
    });

    const serializer = new XMLSerializer();
    const svgString = serializer.serializeToString(clone);
    const encoded = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svgString);
    const img = new Image();
    img.src = encoded;
    await new Promise((res, rej) => { img.onload = res; img.onerror = rej; });

    let vbW = null, vbH = null;
    const vb = svgNode.getAttribute('viewBox');
    if(vb) {
      const parts = vb.trim().split(/\s+/).map(Number);
      if(parts.length === 4 && parts[2] && parts[3]) {
        vbW = parts[2]; vbH = parts[3];
      }
    }

    const dispW = svgNode.clientWidth || svgNode.getBoundingClientRect().width || maxWidth;
    const dispH = svgNode.clientHeight || svgNode.getBoundingClientRect().height || (dispW * 9/16);

    let canvasW, canvasH;
    if(vbW && vbH) {
      const scale = Math.min(maxWidth / vbW, 1.5);
      canvasW = Math.round(vbW * scale);
      canvasH = Math.round(vbH * scale);
    } else {
      const ratio = dispW && dispH ? (dispH/dispW) : (9/16);
      canvasW = Math.round(Math.min(maxWidth, dispW));
      canvasH = Math.round(canvasW * ratio);
    }

    const canvas = document.createElement('canvas');
    canvas.width = canvasW;
    canvas.height = canvasH;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#fff';
    ctx.fillRect(0,0,canvas.width, canvas.height);
    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
    return canvas.toDataURL('image/png', 0.9);
  }

  if(addBtn) addBtn.addEventListener('click', async function(e){
    e.preventDefault();
    
    const designer = DESIGNERS[currentDesigner];

    if (!designer.available) {
      const userEmail = prompt(`Enter your email to be notified when ${designer.name} becomes available:`);
      
      if (!userEmail || !userEmail.includes('@')) {
        if (userEmail !== null) alert('Please enter a valid email address');
        return;
      }
      
      addBtn.disabled = true;
      addBtn.textContent = 'Saving...';
      
      try {
        const pngDataUrl = await svgToPngDataUrl(svg, 1000);
        const sizeText = sizeSelect ? sizeSelect.value : 'M';
        
        const response = await fetch('https://uploads.pabon.shop/waitlist_handler.php', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            email: userEmail,
            designer: designer.name,
            size: sizeText,
            designImage: pngDataUrl
          })
        });
        
        const result = await response.json();
        
        if (result.success) {
          alert(result.message + '\n\n' + result.total_interested + ' people interested in this colorway!');
        } else {
          alert('Error: ' + result.message);
        }
      } catch (err) {
        alert('Failed to save notification: ' + err.message);
      } finally {
        addBtn.disabled = false;
        addBtn.textContent = 'NOTIFY ME';
      }
      return;
    }
    
    if(addBtn.disabled) {
      alert('Cannot add to cart: color constraints exceeded. Please reduce the number of colors used.');
      return;
    }
    
    // Check if we have a product variant ID
    if (!SINGLE_VARIANT_ID) {
      alert('⚠️ Product not configured!\n\nPlease follow these steps:\n\n1. Go to Customize Theme\n2. Click on the Sweater Designer section\n3. Select your sweater product\n4. Save\n\nOr paste a Variant ID in the Fallback field.\n\nPress Ctrl+D to see debug info.');
      console.error('No variant ID found. Configure the section settings or check the console for details.');
      return;
    }
    
    if(addBtn.dataset.busy === '1') return;
    addBtn.dataset.busy = '1';
    addBtn.style.opacity = '0.6';
    const origText = addBtn.textContent;
    addBtn.textContent = 'Processing...';

    try {
      if(!svg) throw new Error('SVG not found.');

      const pngDataUrl = await svgToPngDataUrl(svg, 1000);
      
      // Always use the single variant ID
      const chosenVariant = SINGLE_VARIANT_ID;

      const timestamp = Date.now();
      const designerClean = designer.name.replace(/\s+/g, '_');
      const designId = `${designerClean}_${timestamp}`;
      const customName = designer.name + ' Design';

      // Get size from selector (stored as property, not variant)
      const sizeText = sizeSelect ? sizeSelect.value : 'M';
      
      console.log('=== SIZE DEBUG ===');
      console.log('Size selector value:', sizeText);
      console.log('Size will be stored in Size property');
      console.log('==================');

      const colorMapping = {};
      const swatchColors = getSwatchColors(currentDesigner);
      swatchColors.forEach(color => {
        colorMapping[normalizeColor(color.hex)] = color.name;
      });

      function countLayersByColor(layers) {
        const colorCounts = {};
        
        layers.forEach(layerId => {
          const color = getFill(layerId);
          if (color) {
            const normalizedColor = normalizeColor(color);
            const colorName = colorMapping[normalizedColor] || normalizedColor;
            
            if (!colorCounts[colorName]) {
              colorCounts[colorName] = {
                hex: normalizedColor,
                count: 0,
                layers: []
              };
            }
            colorCounts[colorName].count++;
            colorCounts[colorName].layers.push(layerId);
          }
        });
        
        return colorCounts;
      }

      const bodyLayerCounts = countLayersByColor(bodyLayers);
      const leftSleeveLayerCounts = countLayersByColor(leftSleeveLayers);
      const rightSleeveLayerCounts = countLayersByColor(rightSleeveLayers);
      const hemLayerCounts = countLayersByColor(hemLayers);

      const bodyUsed = Object.keys(bodyLayerCounts);
      const leftSleeveUsed = Object.keys(leftSleeveLayerCounts);
      const rightSleeveUsed = Object.keys(rightSleeveLayerCounts);
      
      const allLayerCounts = {};
      
      function addToTotalCounts(sectionCounts, sectionName) {
        Object.entries(sectionCounts).forEach(([colorName, data]) => {
          if (!allLayerCounts[colorName]) {
            allLayerCounts[colorName] = {
              hex: data.hex,
              bodyStripes: 0,
              leftSleeveStripes: 0,
              rightSleeveStripes: 0,
              hemStripes: 0,
              totalStripes: 0
            };
          }
          
          if (sectionName === 'body') allLayerCounts[colorName].bodyStripes = data.count;
          if (sectionName === 'leftSleeve') allLayerCounts[colorName].leftSleeveStripes = data.count;
          if (sectionName === 'rightSleeve') allLayerCounts[colorName].rightSleeveStripes = data.count;
          if (sectionName === 'hem') allLayerCounts[colorName].hemStripes = data.count;
          
          allLayerCounts[colorName].totalStripes += data.count;
        });
      }
      
      addToTotalCounts(bodyLayerCounts, 'body');
      addToTotalCounts(leftSleeveLayerCounts, 'leftSleeve');
      addToTotalCounts(rightSleeveLayerCounts, 'rightSleeve');
      addToTotalCounts(hemLayerCounts, 'hem');
      
      const productionSummary = Object.entries(allLayerCounts)
        .sort((a, b) => b[1].totalStripes - a[1].totalStripes)
        .map(([colorName, counts]) => {
          return `${colorName}: ${counts.totalStripes} stripes total (Body:${counts.bodyStripes}, L:${counts.leftSleeveStripes}, R:${counts.rightSleeveStripes}, Hem:${counts.hemStripes})`;
        })
        .join('; ');
      
      let publicImageUrl = '';
      let uploadSuccess = false;
      
      try {
        console.log('Uploading design to server...');
        
        const formatColorStripes = (counts) => {
          return Object.entries(counts)
            .map(([name, data]) => `${name} (${data.count} ${data.count === 1 ? 'stripe' : 'stripes'})`)
            .join(', ');
        };
        
        const uploadPayload = {
          imageData: pngDataUrl,
          designId: designId,
          designerName: designer.name,
          properties: {
            size: sizeText,
            bodyColors: `Body (${bodyLayers.length} stripes): ${formatColorStripes(bodyLayerCounts)}`,
            leftSleeveColors: `Left Sleeve (${leftSleeveLayers.length} stripes): ${formatColorStripes(leftSleeveLayerCounts)}`,
            rightSleeveColors: `Right Sleeve (${rightSleeveLayers.length} stripes): ${formatColorStripes(rightSleeveLayerCounts)}`,
            hemColors: `Hem (${hemLayers.length} stripes): ${formatColorStripes(hemLayerCounts)}`,
            productionSummary: productionSummary,
            totalStripes: Object.values(allLayerCounts).reduce((sum, c) => sum + c.totalStripes, 0),
            uniqueColors: Object.keys(allLayerCounts).length,
            timestamp: new Date().toISOString()
          }
        };
        
        const uploadResponse = await fetch('https://uploads.pabon.shop/upload.php', {
          method: 'POST',
          headers: { 
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(uploadPayload)
        });
        
        const uploadResult = await uploadResponse.json();
        console.log('Upload response:', uploadResult);
        
        if (uploadResult.success) {
          publicImageUrl = uploadResult.url;
          uploadSuccess = true;
          console.log('Design uploaded successfully. URL:', publicImageUrl);
        } else {
          console.error('Upload failed:', uploadResult.message);
        }
      } catch (uploadError) {
        console.error('Upload error:', uploadError);
      }
      
      const properties = { 
        "_Custom_Name": customName,
        "_Designer": designer.name,
        "_Design_ID": designId,
        "_Design_Date": new Date().toISOString().split('T')[0],
        "Size": sizeText,
        "_Design_PNG": pngDataUrl
      };
      
      if (uploadSuccess && publicImageUrl) {
        properties["_Design_Image_URL"] = publicImageUrl;
        properties["_Design_Status"] = "Uploaded Successfully";
      } else {
        properties["_Design_Status"] = "Upload Pending - Check Server";
        properties["_Design_Image_URL"] = "";
      }
      
      properties["_Body_Colors"] = bodyLayers.length > 0 ? 
        `Body (${bodyLayers.length} stripes): ${
          Object.entries(bodyLayerCounts)
            .map(([name, data]) => `${name} (${data.count} ${data.count === 1 ? 'stripe' : 'stripes'})`)
            .join(', ')
        }` : 'Body: No stripes';
      
      properties["_Left_Sleeve_Colors"] = leftSleeveLayers.length > 0 ?
        `Left Sleeve (${leftSleeveLayers.length} stripes): ${
          Object.entries(leftSleeveLayerCounts)
            .map(([name, data]) => `${name} (${data.count} ${data.count === 1 ? 'stripe' : 'stripes'})`)
            .join(', ')
        }` : 'Left Sleeve: No stripes';
      
      properties["_Right_Sleeve_Colors"] = rightSleeveLayers.length > 0 ?
        `Right Sleeve (${rightSleeveLayers.length} stripes): ${
          Object.entries(rightSleeveLayerCounts)
            .map(([name, data]) => `${name} (${data.count} ${data.count === 1 ? 'stripe' : 'stripes'})`)
            .join(', ')
        }` : 'Right Sleeve: No stripes';
      
      properties["_Hem_Colors"] = hemLayers.length > 0 ?
        `Hem/Cuffs (${hemLayers.length} stripes): ${
          Object.entries(hemLayerCounts)
            .map(([name, data]) => `${name} (${data.count} ${data.count === 1 ? 'stripe' : 'stripes'})`)
            .join(', ')
        }` : 'Hem/Cuffs: No stripes';
      
      properties["_Production_Summary"] = productionSummary;
      properties["_Total_Stripes"] = `${Object.values(allLayerCounts).reduce((sum, c) => sum + c.totalStripes, 0)} stripes across all sections`;
      properties["_Unique_Colors"] = `${Object.keys(allLayerCounts).length} unique colors`;
      
      const totalStripes = Object.values(allLayerCounts).reduce((sum, c) => sum + c.totalStripes, 0);
      const estimatedWeight = (totalStripes * 100) / 1000;
      properties["_Material_Estimate"] = `Approximately ${estimatedWeight.toFixed(2)} kg total wool needed`;

      console.log('Adding to cart with properties:', properties);
      console.log('Using single variant ID:', chosenVariant);
      
      const addResp = await fetch('/cart/add.js', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ 
          id: chosenVariant, 
          quantity: 1, 
          properties: properties 
        })
      });

      if(!addResp.ok) {
        const err = await addResp.json().catch(()=>({ message: 'Add to cart failed' }));
        throw new Error(err?.description || err?.message || 'Add failed');
      }

      const cartItem = await addResp.json();
      console.log('Successfully added to cart:', cartItem);

      if (uploadSuccess && publicImageUrl) {
        try {
          await fetch('https://uploads.pabon.shop/notify_order.php', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              design_id: designId,
              design_url: publicImageUrl,
              designer: designer.name,
              size: sizeText,
              properties: properties,
              production_data: allLayerCounts,
              cart_token: cartItem.key || '',
              timestamp: new Date().toISOString()
            })
          });
          console.log('Server notified of pending order with production data');
          console.log('Size sent to factory:', sizeText);
        } catch (notifyError) {
          console.warn('Notification failed (non-critical):', notifyError);
        }
      }

      showConfirmation();

      console.log('Design successfully added to cart. Customer can download from order details.');

    } catch(err) {
      console.error('Add-to-cart error', err);
      alert('Error adding to cart: ' + (err.message || err));
    } finally {
      addBtn.dataset.busy = '0';
      addBtn.style.opacity = '1';
      addBtn.textContent = origText;
    }
  });

  makeShapesClickable();
  buildSwatches();
  applyDefaults();
  refreshConstraints();
  updateAddToCartButton();
  updateMiniThumbnail(0);
  syncMobileButtons();

  // Color picker tooltip functionality
  const colorPickerTooltip = document.getElementById('color-picker-tooltip');
  let tooltipDismissed = false;

  function showColorPickerTooltip() {
    if (!tooltipDismissed && colorPickerTooltip) {
      colorPickerTooltip.style.display = 'block';
    }
  }

  function hideColorPickerTooltip() {
    if (colorPickerTooltip) {
      colorPickerTooltip.style.display = 'none';
      tooltipDismissed = true;
    }
  }

  setTimeout(showColorPickerTooltip, 500);

  if (colorPickerTooltip) {
    colorPickerTooltip.addEventListener('mouseenter', hideColorPickerTooltip);
  }

  document.addEventListener('click', function(e) {
    if (e.target.classList.contains('color-swatch')) {
      hideColorPickerTooltip();
    }
  });

  // ========== TUTORIAL ANIMATION ==========
  const tutorialBtn = document.getElementById('tutorial-btn');
  const tutorialCursor = document.getElementById('tutorial-cursor');
  let tutorialPlaying = false;

  if (tutorialBtn && tutorialCursor) {
    tutorialBtn.addEventListener('click', playTutorial);
  }

  async function playTutorial() {
    if (tutorialPlaying) return;
    tutorialPlaying = true;
    tutorialBtn.classList.add('playing');
    tutorialBtn.textContent = '⏸';
    
    // Get elements - find the actual shape elements that have click handlers
    const allSwatches = swatchContainer.querySelectorAll('.color-swatch');
    const firstSwatch = allSwatches[0];
    const secondSwatch = allSwatches[1];
    
    // Find stripe elements from their parent groups
    const firstStripeGroup = document.getElementById('Laag_3');
    const firstStripe = firstStripeGroup ? firstStripeGroup.querySelector('path, rect, polygon, polyline, circle, ellipse') : null;
    
    const secondStripeGroup = document.getElementById('Laag_5');
    const secondStripe = secondStripeGroup ? secondStripeGroup.querySelector('path, rect, polygon, polyline, circle, ellipse') : null;
    
    if (!firstSwatch || !firstStripe) {
      tutorialPlaying = false;
      tutorialBtn.classList.remove('playing');
      tutorialBtn.textContent = '?';
      return;
    }
    
    // Helper function to move cursor
    function moveCursor(element, duration = 800) {
      return new Promise(resolve => {
        const rect = element.getBoundingClientRect();
        const x = rect.left + rect.width / 2;
        const y = rect.top + rect.height / 2;
        
        tutorialCursor.style.transition = `all ${duration}ms cubic-bezier(0.4, 0, 0.2, 1)`;
        tutorialCursor.style.left = x + 'px';
        tutorialCursor.style.top = y + 'px';
        
        setTimeout(resolve, duration);
      });
    }
    
    // Helper function to click animation
    function simulateClick() {
      return new Promise(resolve => {
        tutorialCursor.classList.add('clicking');
        setTimeout(() => {
          tutorialCursor.classList.remove('clicking');
          resolve();
        }, 300);
      });
    }
    
    // Helper to actually change stripe color
    function changeStripeColor(stripe, color) {
      if (stripe && color) {
        stripe.style.fill = normalizeColor(color);
      }
    }
    
    // Start animation - position cursor off screen
    tutorialCursor.classList.add('active');
    tutorialCursor.style.transition = 'none';
    tutorialCursor.style.left = '-100px';
    tutorialCursor.style.top = '-100px';
    tutorialCursor.style.opacity = '1';
    
    await new Promise(resolve => setTimeout(resolve, 100));
    
    // FIRST INTERACTION
    // Step 1: Move to first swatch
    firstSwatch.classList.add('tutorial-highlight');
    await moveCursor(firstSwatch, 1000);
    await new Promise(resolve => setTimeout(resolve, 300));
    
    // Step 2: Click swatch and select color
    await simulateClick();
    firstSwatch.classList.remove('tutorial-highlight');
    firstSwatch.click(); // Select the swatch
    const firstColor = firstSwatch.style.backgroundColor || getComputedStyle(firstSwatch).backgroundColor;
    await new Promise(resolve => setTimeout(resolve, 500));
    
    // Step 3: Move to first stripe
    firstStripe.classList.add('tutorial-highlight');
    await moveCursor(firstStripe, 1000);
    await new Promise(resolve => setTimeout(resolve, 300));
    
    // Step 4: Click stripe and apply color
    await simulateClick();
    firstStripe.classList.remove('tutorial-highlight');
    changeStripeColor(firstStripe, activeColor); // Use the active color
    refreshConstraints();
    await new Promise(resolve => setTimeout(resolve, 800));
    
    // SECOND INTERACTION
    if (secondSwatch && secondStripe) {
      // Move to second swatch
      secondSwatch.classList.add('tutorial-highlight');
      await moveCursor(secondSwatch, 800);
      await new Promise(resolve => setTimeout(resolve, 200));
      
      // Click second swatch
      await simulateClick();
      secondSwatch.classList.remove('tutorial-highlight');
      secondSwatch.click();
      await new Promise(resolve => setTimeout(resolve, 400));
      
      // Move to second stripe
      secondStripe.classList.add('tutorial-highlight');
      await moveCursor(secondStripe, 800);
      await new Promise(resolve => setTimeout(resolve, 200));
      
      // Click second stripe and apply color
      await simulateClick();
      secondStripe.classList.remove('tutorial-highlight');
      changeStripeColor(secondStripe, activeColor);
      refreshConstraints();
      await new Promise(resolve => setTimeout(resolve, 500));
    }
    
    // End animation - fade out and hide cursor
    tutorialCursor.style.transition = 'opacity 0.3s ease';
    tutorialCursor.style.opacity = '0';
    
    await new Promise(resolve => setTimeout(resolve, 300));
    
    tutorialCursor.classList.remove('active');
    tutorialCursor.style.left = '-100px';
    tutorialCursor.style.top = '-100px';
    
    tutorialPlaying = false;
    tutorialBtn.classList.remove('playing');
    tutorialBtn.textContent = '?';
  }
  // ========== END TUTORIAL ANIMATION ==========
}
</script>